from enum import Enum

"""
    This file defines a bunch of classes related to Stratego, game representation etc.
    To check game logic implementation check stratego.py
"""


class PieceType(Enum):
    flag = 0
    spy = 1
    scout = 2
    miner = 3
    sergeant = 4
    lieutenant = 5
    captain = 6
    major = 7
    colonel = 8
    general = 9
    marshal = 10
    mine = 100


_lake_set = {42, 43, 46, 47, 52, 53, 56, 57}
_piece_type_setup_count: dict[PieceType, int] = {
    PieceType.flag: 1,
    PieceType.spy: 1,
    PieceType.scout: 8,
    PieceType.miner: 5,
    PieceType.sergeant: 4,
    PieceType.lieutenant: 4,
    PieceType.captain: 4,
    PieceType.major: 3,
    PieceType.colonel: 2,
    PieceType.general: 1,
    PieceType.marshal: 1,
    PieceType.mine: 6
}
_immobile_set = {PieceType.flag, PieceType.mine}
_mobile_set = {piece_type for piece_type in PieceType if piece_type not in _immobile_set}


class Side(Enum):
    red = False
    blue = True

    def flip(self):
        return Side.red if self.value else Side.blue


class Piece:
    """
        Represents a single piece on the board.
    """

    def __init__(self, color: Side, piece_type: PieceType):
        self.color = color
        self.type = piece_type
        self.discovered = False

    def to_json(self):
        return {
            "color": "red" if self.color is Side.red else "blue",
            "type": _piece_type_to_str[self.type],
            "discovered": self.discovered
        }


_piece_type_to_str: dict[PieceType, str] = {
    PieceType.flag: "F",
    PieceType.spy: "S",
    PieceType.scout: "2",
    PieceType.miner: "3",
    PieceType.sergeant: "4",
    PieceType.lieutenant: "5",
    PieceType.captain: "6",
    PieceType.major: "7",
    PieceType.colonel: "8",
    PieceType.general: "9",
    PieceType.marshal: "10",
    PieceType.mine: "B"
}


class GameStateViewToken:
    """
        This class is meant to represent a singular piece in player view.
        In that system pieces can be "Unknown", or have a defined value.
        Possible "type" values:
        "?" - Unknown,
        "F" - Flag,
        "B" - bomb/mine,
        "S" - Spy,
        from "2" to "10" - rest of army
    """

    def __init__(self, symbol: str, side: Side):
        self.type: str = symbol
        self.side: Side = side

    def to_json(self):
        return {"side": "red" if self.side is Side.red else "blue",
                "type": self.type}


class GameStateView:
    """
    This class is designed to represent how given player should see the board.
    Ideally, stratego we would want to expose this class to the client, instead of raw board game state.
    Doing so we could prevent some clients from "peeking" on their opponents
    """

    def __init__(self, view: list[GameStateViewToken | None]):
        self._view = view

    def get_view(self):
        return self._view

    def __getitem__(self, item):
        return self._view[item]


class GameState:

    def __init__(self, board: list[None | Piece], side_to_move: Side):
        assert len(board) == 100
        self._board: list[None | Piece] = board
        self._side_to_move: Side = side_to_move

    def get_side_to_move(self):
        return self._side_to_move

    def get_board(self):
        return self._board.copy()

    @staticmethod
    def __generate_token(piece: Piece | None, viewer_side: Side | None) -> GameStateViewToken | None:
        """
        Generates a token object (representing a piece or an unknown value) to be displayed in the game view based on
        the given piece and the viewing side's color. If the piece is None or the viewing side's color does not
        match, returns `None`, otherwise returns either `"?"` (if the piece has not been discovered yet) or a string
        representing the type of the piece.
        """
        if piece is None:
            return piece

        if viewer_side is not piece.color and not piece.discovered:
            return GameStateViewToken("?", piece.color)

        return GameStateViewToken(_piece_type_to_str[piece.type], piece.color)

    def get_view(self, side: Side | None) -> GameStateView:
        """
        Returns a view object containing all the pieces in the game state, with their corresponding token objects
        based on the viewing side's color (as generated by `__generate_token()`). This method is used to display the
        game state to the player.
        """
        result = [self.__generate_token(piece, side) for piece in self._board]
        return GameStateView(result)


def verify_setup_dict(setup: dict[int, PieceType], side: Side) -> bool:
    """
    This functions simply checks if given dictionary is correct setup according to project documentation:
    1. All pieces are placed in territory allowed for this side to set up
    2. Each PieceType is present in dictionary precisely the amount of times specified in documentation
    for given piece type.

    :param setup: A python dictionary that maps square ids to PieceType.
    :param side: Side for which we are checking correctness
    :return: True if setup is valid, false otherwise
    """

    # We don't actually need this check
    # if len(setup) != 40:
    #    return False

    allowed_area = range(40) if side.value else range(60, 100)

    for key in setup.keys():
        if key not in allowed_area:
            return False

    temp_dict = {piece_type: 0 for piece_type in PieceType}

    for v in setup.values():
        temp_dict[v] += 1

    for piece_type in PieceType:
        if temp_dict[piece_type] != _piece_type_setup_count[piece_type]:
            return False

    return True


def game_state_from_setups(red_setup: dict[int, PieceType], blue_setup: dict[int, PieceType]) -> GameState:
    """
    This function simply generates a valid input for GameState.set_game_state() method.
    """
    result: list[Piece | None] = [None] * 100

    for key in red_setup.keys():
        result[key] = Piece(Side.red, red_setup[key])

    for key in blue_setup.keys():
        result[key] = Piece(Side.blue, blue_setup[key])

    return GameState(result, Side.red)
